<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Sa-Is</title>
    <url>/post/sa-is/</url>
    <content><![CDATA[<h1 id="sa-is算法">SA-IS算法</h1>
<h2 id="前言">前言</h2>
<p>先丢个洛谷日报的链接<a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/on-hou-zhui-shuo-zu-sa-is-suan-fa" target="_blank" rel="noopener">SA-IS算法</a>。一下慢慢解读<del>抄袭</del>这篇博客。本文也可以与<a href="https://www.luogu.org/space/show?uid=56384" target="_blank" rel="noopener">shadowice1984</a>的洛谷日报同步阅读，<del>增加</del>解释疑惑。</p>
<p>SA-IS算法，全名<strong>S</strong>uffix-<strong>A</strong>rray-<strong>I</strong>nduce-<strong>S</strong>ort。 <strong>induce sort</strong> 指的是一个叫诱导排序的算法（下文重点）。SA-IS算法的精髓便是基于<strong>根据两个后缀首字母是否相同与其他已知信息来比较后缀</strong>的诱导排序。基于诱导排序，本算法可在<span class="math inline">\(O(|S|)\)</span>的时间复杂度内进行后缀排序。</p>
<h2 id="具体实现">具体实现</h2>
<h4 id="s型后缀与l型后缀"><span class="math inline">\(S\)</span>型后缀与<span class="math inline">\(L\)</span>型后缀</h4>
<h4 id="全文阅读注释">全文阅读注释</h4>
<blockquote>
<p>为了方便我们推导各种各样的性质我们先把一个字符串的后缀分成两类,S型后缀和L型后缀，并且为了规避各种各样的分情况讨论，我们在字符串的后面需要加一个哨兵字符“#”。</p>
</blockquote>
<p>好吧，我承认，加个<del>烧饼</del>哨兵字符的确可以方便不少，因为第<span class="math inline">\(|S|\)</span>（下文中字符串长度<span class="math inline">\(|S|\)</span>也会记作<span class="math inline">\(n\)</span>）个字符开始的后缀（第<span class="math inline">\(i\)</span>个字符开始的后缀<del>在原文中</del>也记作：后缀<span class="math inline">\(i\)</span>）需要用到后缀<span class="math inline">\(n+1\)</span>的诸多信息，<del>为了让代码短一点</del>。哨兵字符的大小为比该字符串任意字符小的字符（不影响排序结果）。</p>
<p>记后缀<span class="math inline">\(i\)</span>为<span class="math inline">\(Suf(i)\)</span></p>
<p>记一个后缀<span class="math inline">\(S\)</span>的类型为<span class="math inline">\(S.type\)</span>。（可以跳过去先看一下定义）</p>
<p><strong>例子</strong>： 若<span class="math inline">\(S=\)</span>"<span class="math inline">\(banana\)</span>"，则<span class="math inline">\(Suf(4)=\)</span>"<span class="math inline">\(ana\)</span>"，<span class="math inline">\(Suf(4).type=S\)</span>。</p>
<p>另，记排序后的后缀的开头位置构成的数组为<span class="math inline">\(sa\)</span>（即<a href="https://www.luogu.org/problem/P3809" target="_blank" rel="noopener">洛谷模板题</a>的答案数组），编号由<span class="math inline">\(1\)</span>开始，<span class="math inline">\(sa_1\)</span>明显是指哨兵字符。</p>
<p>注：关于时间复杂度的具体内容（如证明），本文暂且留坑。</p>
<p>注：由于本人代码太丑，贴原博客代码</p>
<h4 id="定义">定义</h4>
<blockquote>
<p>"#"是一个<span class="math inline">\(S\)</span>型后缀。</p>
<p>如果后缀<span class="math inline">\(i\)</span>比后缀<span class="math inline">\(i+1\)</span>小，<span class="math inline">\(i\)</span>就是<span class="math inline">\(S\)</span>型后缀，否则就是<span class="math inline">\(L\)</span>型后缀。</p>
</blockquote>
<h4 id="性质">性质</h4>
<h5 id="推论1若s_is_i1则sufi.typesufi1.type">推论1：若<span class="math inline">\(S_i=S_{i+1}\)</span>，则<span class="math inline">\(Suf(i).type=Suf(i+1).type\)</span></h5>
<p>证明：</p>
<p>由<span class="math inline">\(S_i=S_{i+1}\)</span>，则比较<span class="math inline">\(Suf(i)\)</span>与<span class="math inline">\(Suf(i+1)\)</span>相当于后移一位比较<span class="math inline">\(Suf(i+1)\)</span>与<span class="math inline">\(Suf(i+2)\)</span>。由后缀类型定义即可证得。</p>
<p><strong>注：本文证明以提供思路为主要目的，故并不形式。</strong>希望大佬莫喷。</p>
<h5 id="推论2若s_is_j且sufi.types且sufj.typel则sufisufj">推论2：若<span class="math inline">\(S_i=S_j\)</span>且<span class="math inline">\(Suf(i).type=S\)</span>且<span class="math inline">\(Suf(j).type=L\)</span>，则<span class="math inline">\(Suf(i)&gt;Suf(j)\)</span></h5>
<p>证明：</p>
<p>由<span class="math inline">\(S_i=S_j\)</span>，则须比较<span class="math inline">\(Suf(i+1)\)</span>和<span class="math inline">\(Suf(j+1)\)</span>。由于<span class="math inline">\(Suf(i).type=S\)</span>，则<span class="math inline">\(S_{i+1}\le S_i\)</span>，由于<span class="math inline">\(Suf(j).type=L\)</span>，则<span class="math inline">\(S_{j+1}\le S_j\)</span>。</p>
<p>已知<span class="math inline">\(a_{j+1}\le a_j=a_i \le a_{i+1}\)</span>，若<span class="math inline">\(a_i \ne a_{i+1}\)</span>或<span class="math inline">\(a_j\ne a_{j+1}\)</span>，结论显然成立。</p>
<p>若<span class="math inline">\(a_{j+1}=a_j=a_i=a_{i+1}\)</span>，由<strong>推论1</strong>，<span class="math inline">\(Suf(i+1).type=S,Suf(j+1).type=L\)</span>，问题递归转化为<span class="math inline">\(Suf(i+1)\)</span>与<span class="math inline">\(Suf(j+1)\)</span>。</p>
<p>由数学归纳法，我们只用证明边界情况：字符串末尾。</p>
<p>如果<span class="math inline">\(i&lt;j\)</span>，即类型为<span class="math inline">\(L\)</span>的<span class="math inline">\(j\)</span>判断到了边界，结论明显成立。</p>
<p>如果<span class="math inline">\(i=j\)</span>，明显矛盾。</p>
<p>如果<span class="math inline">\(i&gt;j\)</span>，则是<span class="math inline">\(i\)</span>碰到了边界，即从<span class="math inline">\(i\)</span>到<span class="math inline">\(n\)</span>全部是<span class="math inline">\(S\)</span>型后缀且相等，则不满足<span class="math inline">\(Suf(i)&lt;Suf(i+1)\)</span>，与<span class="math inline">\(S\)</span>型后缀定义矛盾。</p>
<h4 id="代码实现">代码实现</h4>
<p>我们可以先从右到左扫一遍，因为已经处理出来后面每一个后缀的类型，由<strong>推论1</strong>我们就可以求出当前位置的类型。时间复杂度<span class="math inline">\(\Theta(n)\)</span></p>
<h3 id="诱导排序induce-sort">诱导排序(induce sort)</h3>
<blockquote>
<p>sais的核心是诱导排序，但是诱导排序的正确性是基于归纳法证明的.所以这个算法不太好理解，它很简单，但是你可能理解不了为什么它是对的。</p>
</blockquote>
<p>笔者就花了很长时间感性理解这个算法。从现在开始，建议不懂的可以暂时跳过，到后面出问题了或者读到末尾还没懂再回头看，或许会好理解不少。</p>
<p>由<strong>推论2</strong>，易得在后缀数组中首字母相同时<span class="math inline">\(L\)</span>型后缀在<span class="math inline">\(S\)</span>型后缀前面。</p>
<p>那么我们不妨可以将<span class="math inline">\(L\)</span>型后缀和<span class="math inline">\(S\)</span>型后缀<strong>分别排序</strong>，最后用归并排序的思想将后缀数组处理完成。</p>
<p>现在我们从<span class="math inline">\(L\)</span>型后缀开始，思考一下如何对相同类型进行后缀排序。</p>
<p>如果两个<span class="math inline">\(L\)</span>型后缀的首字母不一样，那么很好处理，否则我们就递归比较<span class="math inline">\((i+1,j+1)\)</span>。基于这个思想直接处理有点麻烦，不如我们：</p>
<h4 id="总体思路">总体思路：</h4>
<p><strong>假设</strong>已经知道了部分后缀的大小关系（后文重点介绍，学这个算法切忌着急），然后我们可以将已知的最小的后缀为<span class="math inline">\(Suf(i)\)</span>，那么如果<span class="math inline">\(Suf(i-1).type=L\)</span>，即<span class="math inline">\(Suf(i-1)&gt;Suf(i)\)</span>，将<span class="math inline">\(i-1\)</span>加入我们现在已知的集合中，然后将<span class="math inline">\(i\)</span>放入排序数组，并从集合删除，维护这个集合。最后我们可以知道与初始集合有关的所有<span class="math inline">\(L\)</span>型后缀之间的关系。</p>
<blockquote>
<p>如果用堆来维护刚才的过程，复杂度带log无法接受，但是我们有一个巧妙的做法可以完成上述过程。</p>
</blockquote>
<p><del><em>精益求精的shadowice巨佬！！！</em></del></p>
<p><strong>（依然维持刚才的假设。）</strong>我们直接维护<span class="math inline">\(sa\)</span>数组，先记录每个首字母开头有多少后缀，便可以得知首字母为<span class="math inline">\(i\)</span>的后缀从<span class="math inline">\(sa\)</span>数组的哪里开始和结束。代码实现时先把<span class="math inline">\(sa\)</span>初始化为<span class="math inline">\(-1\)</span>。然后我们刚才插入的过程便可以直接在数组上维护！（具体代码实现部分会有介绍。）</p>
<p>我们从左到右扫一遍<span class="math inline">\(sa\)</span>数组，如果第<span class="math inline">\(i\)</span>个位置已知，且<span class="math inline">\(Suf(sa_i-1).type=L\)</span>，我们就将<span class="math inline">\(L\)</span>型后缀<span class="math inline">\(Suf(sa_i-1)\)</span>插入到下一个位置。</p>
<blockquote>
<p>(你可以把插入的过程理解为将sa数组按照首字母划分为若干个桶，然后将这个后缀push到对应的桶里去，代码上写起来和倍增法的基排没啥区别）</p>
</blockquote>
<p>这样子，我们便可以<strong>在假设的基础上</strong>，用<span class="math inline">\(\Theta(n)\)</span>的时间复杂度实现上述算法。</p>
<p>如果我们知道所有<span class="math inline">\(S\)</span>型后缀，我们便可以用上述算法得到所有<span class="math inline">\(L\)</span>型数组；对称的，知道所有<span class="math inline">\(L\)</span>型后缀，也可以得到所有<span class="math inline">\(S\)</span>型后缀。（这就是诱导排序的主体部分）</p>
<p>原理很简单：以从<span class="math inline">\(S\)</span>型导入到<span class="math inline">\(L\)</span>型为例，由于最后一个不是<span class="math inline">\(L\)</span>型，每一个<span class="math inline">\(L\)</span>型后缀<span class="math inline">\(Suf(i)\)</span>都可以由<span class="math inline">\(Suf(i+1)\)</span>得到，因为是<span class="math inline">\(L\)</span>型，所以<span class="math inline">\(Suf(i)&gt;Suf(i+1)\)</span>是肯定成立的（具体类似于<strong>推论2</strong>，可以由<strong>推论1</strong>证明，有兴趣可以自证）。这样子，<span class="math inline">\(L\)</span>型后缀按顺序插入，不会有遗漏。</p>
<p><span class="math inline">\(S\)</span>型后缀的加入则要换个顺序，道理是对称的。</p>
<blockquote>
<p>这样只要我们一开始掌握的后缀的大小信息无误并且足够的多，我们就能正确的还原出一个有序的sa数组，具体点，我们知道了关于S型的大小信息可以生成L型后缀的信息，知道了L型后缀的信息也可以还原出S型后缀的所有信息。</p>
</blockquote>
<p>但是，前提是<strong>刚才的假设</strong>……</p>
<p>（只要你知道了诱导排序的作用就请先看下去，后面有lms子串诱导排序的模拟过程）</p>
<h4 id="全文重点">全文重点！！！</h4>
<h5 id="lms子串与lms后缀">lms子串与lms后缀</h5>
<p>为了方便处理这个棘手的问题，我们先引入一个概念：lms子串</p>
<p>诱导排序算法允许我们从<span class="math inline">\(L\)</span>诱导到<span class="math inline">\(S\)</span>，也允许从<span class="math inline">\(S\)</span>诱导到<span class="math inline">\(L\)</span>。但是诱导时并不需要全部的信息，我们只用扫描方向边界的信息即可。具体而言：</p>
<blockquote>
<p>把诱导排序算法的正确性证明念一遍，我们会发现关键在于递归比较<span class="math inline">\((Suf(i+1),Suf(j+1))\)</span>的大小关系这一段，如果<span class="math inline">\(Suf(i)\)</span>和都是<span class="math inline">\(Suf(j)\)</span>都是L型后缀，我们不能保证<span class="math inline">\((Suf(i+1),Suf(j+1))\)</span>都是L型后缀。</p>
</blockquote>
<p>但是，我们也仅仅需要左边是<span class="math inline">\(L\)</span>型后缀的<span class="math inline">\(S\)</span>型后缀的大小信息了。我们把这样的后缀定义为lms后缀(<strong>L</strong>eft-<strong>M</strong>ost-<strong>S</strong>uffix)。</p>
<p>我们可以把诱导排序升级到2.0版本：<strong>假设我们已经知道了所有lms后缀的大小关系，</strong>先从lms后缀大小关系诱导出<span class="math inline">\(L\)</span>型后缀的大小关系，再诱导到<span class="math inline">\(S\)</span>型。这样我们就可以知道最终的答案了。</p>
<p>由于已经有脑洞打开的神仙解决了这个难题假设，我们就可以省许多脑细胞了：</p>
<p>虽然是<span class="math inline">\(\Theta(n)\)</span>，但是我们依然可以<strong>递归</strong>！！！</p>
<p>显然，最多有<span class="math inline">\(\frac{n}{2}\)</span>个lms后缀，时间复杂度即是： <span class="math display">\[
T(n)=T(\frac{n}{2})+\Theta(n)\notag
\]</span> <del>但是我们还是不会递归问题</del></p>
<p>我们定义lms子串为从左到右数第<span class="math inline">\(i\)</span>个lms后缀和<span class="math inline">\(i+1\)</span>个lms后缀之间的字符串。</p>
<p><strong>例子：</strong></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(i\)</span></th>
<th><span class="math inline">\(1\)</span></th>
<th><span class="math inline">\(2\)</span></th>
<th><span class="math inline">\(3\)</span></th>
<th><span class="math inline">\(4\)</span></th>
<th><span class="math inline">\(5\)</span></th>
<th><span class="math inline">\(6\)</span></th>
<th><span class="math inline">\(7\)</span></th>
<th><span class="math inline">\(8\)</span></th>
<th><span class="math inline">\(9\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(S_i\)</span></td>
<td>b</td>
<td>a</td>
<td>n</td>
<td>a</td>
<td>n</td>
<td>a</td>
<td>a</td>
<td>s</td>
<td>#</td>
</tr>
<tr class="even">
<td><span class="math inline">\(Suf(i).type\)</span></td>
<td><span class="math inline">\(L\)</span></td>
<td><span class="math inline">\(S\)</span></td>
<td><span class="math inline">\(L\)</span></td>
<td><span class="math inline">\(S\)</span></td>
<td><span class="math inline">\(L\)</span></td>
<td><span class="math inline">\(S\)</span></td>
<td><span class="math inline">\(S\)</span></td>
<td><span class="math inline">\(L\)</span></td>
<td><span class="math inline">\(S\)</span></td>
</tr>
<tr class="odd">
<td>是否为lms</td>
<td></td>
<td>是</td>
<td></td>
<td>是</td>
<td></td>
<td>是</td>
<td></td>
<td></td>
<td>是</td>
</tr>
</tbody>
</table>
<p>lms子串为<span class="math inline">\([2,4]\)</span>、<span class="math inline">\([4,6]\)</span>和<span class="math inline">\([6,9]\)</span></p>
<p><strong>注意</strong>：相邻两个lms子串会<strong>重叠一个字符</strong>。</p>
<p>我们可以将lms子串离散化之后再按顺序拼成一个新的字符串，比如说对上面的lms子串进行离散化后变成<span class="math inline">\(2\)</span>、<span class="math inline">\(2\)</span>、<span class="math inline">\(1\)</span>。拼成字符串"221"。</p>
<p>就是把一串字符离散成一个字符（往往读入完会进行第一次离散，所有字符变成数字处理）。</p>
<blockquote>
<p>但是其实并没有我们想的那么显然，我们接下来会严谨的证明离散化的正确性。</p>
<p>首先先明确一下比较lms子串的规则，我们比较两个lms子串的时候对于每一个字符同时比较字符的字典序大小和所在位置后缀的<span class="math inline">\(S\)</span><span class="math inline">\(L\)</span>类型,举个例子，我们认为<span class="math inline">\((&#39;a&#39;,S)\)</span>和<span class="math inline">\((&#39;a&#39;,L)\)</span>是不相等的，尽管字符一样但是所在位置的<span class="math inline">\(S\)</span>和<span class="math inline">\(L\)</span>类型却不一样，同时我们认为<span class="math inline">\(S\)</span>类型大于<span class="math inline">\(L\)</span>类型。</p>
<p>假设我们有两个lms后缀：第<span class="math inline">\(i\)</span>个lms后缀<span class="math inline">\(Suf(p_1)\)</span>和第<span class="math inline">\(j\)</span>个lms后缀<span class="math inline">\(Suf(p_2)\)</span>,现在我们想要比较两个后缀的大小，我们可以根据两个后缀在新字符串上第一位的字符（<span class="math inline">\(S_i\)</span>和<span class="math inline">\(S_j\)</span>）是否相等来进行分情况讨论。</p>
<p><strong>case1:第一位的字符是相等的</strong></p>
<p>我们发现新字符串上两个字符相等,等价于原来字符串上两个lms子串相等，那么既然两个lms子串相等了那么这两个子串的长度<span class="math inline">\(len\)</span>必然是一样的，因此我们可以将两个后缀同时去掉长度为<span class="math inline">\(len-1\)</span>的部分递归比较剩下的部分，在新字符串上也就是递归到了第<span class="math inline">\(i+1\)</span>位和第<span class="math inline">\(j+1\)</span>位，符合我们字符串比较的逻辑。</p>
<p><strong>case2:第一位的字符是不等的</strong></p>
<p>那么你可能会说:既然新字符串的两个字符都不一样了，就说明在原来的字符串上肯定有不一样的位，所以这种情况是显然的。</p>
<p>那好像我们忽视了一种情况哎，两个lms子串代表的字符不一样是因为其中一个是另一个的前缀。</p>
<p>这种情况下我们的算法就会锅掉，因为两个后缀明明没有分出大小我们就强行钦定一个大于另一个了。</p>
<p>事实果真如此吗？</p>
<p>答案是这种情况不存在，我们比较lms子串的规则是同时比较字符和<span class="math inline">\(S\)</span><span class="math inline">\(L\)</span>类型的后缀，在这种情况下不存在一个lms子串是另一个的前缀，因为一个lms子串的<span class="math inline">\(S\)</span><span class="math inline">\(L\)</span>类型必须是形如<span class="math inline">\(SSSSLLLLS\)</span>这样的，前面是一串<span class="math inline">\(S\)</span>中间是一串<span class="math inline">\(L\)</span>，最后是恰好一个<span class="math inline">\(S\)</span>，那么我们发现如果一个是另一个的前缀，两个串必然会在短的字符串的结尾处<span class="math inline">\(S\)</span><span class="math inline">\(L\)</span>类型不匹配，从而不存在这种情况。</p>
</blockquote>
<p>现在就是怎么离散的问题没解决了。</p>
<h5 id="离散化lms子串与诱导排序之间的关系">离散化lms子串与诱导排序之间的关系</h5>
<blockquote>
<p>如果我们实现这一步使用的是<strong>基数排序</strong>那么我们将会得到传说中的KA-algorithm，但是这东西很慢啊……我们想想有没有什么优秀的排序做法。</p>
</blockquote>
<p><del><em>好吧……</em></del></p>
<blockquote>
<p>答案还是诱导排序，传统的诱导排序要求我们传一个有序的lms后缀数组进去，但是现在我们可以乱序传入lms后缀数组，当然诱导排序会返回一个错误的结果，</p>
<p>但是我们断言，在返回的后缀数组当中关于lms后缀的<strong>子序列</strong>是按照每个lms后缀<strong>开头的lms子串</strong>为关键字进行排序的</p>
</blockquote>
<p>呃……有点难理解，我们举一个例子：</p>
<p><span class="math inline">\(bananaas\)</span>#<del>怎么又是这个串</del></p>
<p>lms后缀的数组：</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(i\)</span></th>
<th><span class="math inline">\(1\)</span></th>
<th><span class="math inline">\(2\)</span></th>
<th><span class="math inline">\(3\)</span></th>
<th><span class="math inline">\(4\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(lms_i\)</span></td>
<td><span class="math inline">\(2\)</span>（<span class="math inline">\(ananaas\)</span>#）</td>
<td><span class="math inline">\(4\)</span>（<span class="math inline">\(anaas\)</span>#）</td>
<td><span class="math inline">\(6\)</span>（<span class="math inline">\(aas\)</span>#）</td>
<td><span class="math inline">\(9\)</span>（#）</td>
</tr>
</tbody>
</table>
<p>显然，初始是按起始位置排序的。</p>
<p>记录每一个字符结束位置的<span class="math inline">\(sum\)</span>数组（其实就是桶数组的前缀和）（为了方便理解，初始时不进行离散化，即下标为字符）：</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(i\)</span></th>
<th><span class="math inline">\(&#39;\)</span>#<span class="math inline">\(&#39;\)</span></th>
<th><span class="math inline">\(&#39;a&#39;\)</span></th>
<th><span class="math inline">\(&#39;b&#39;\)</span></th>
<th><span class="math inline">\(&#39;n&#39;\)</span></th>
<th><span class="math inline">\(&#39;s&#39;\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(sum_i\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(5\)</span></td>
<td><span class="math inline">\(6\)</span></td>
<td><span class="math inline">\(8\)</span></td>
<td><span class="math inline">\(9\)</span></td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(sa\)</span>数组先按倒序（在<span class="math inline">\(sa\)</span>数组中便是正序）插入lms后缀：</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(i\)</span></th>
<th><span class="math inline">\(1\)</span></th>
<th><span class="math inline">\(2\)</span></th>
<th><span class="math inline">\(3\)</span></th>
<th><span class="math inline">\(4\)</span></th>
<th><span class="math inline">\(5\)</span></th>
<th><span class="math inline">\(6\)</span></th>
<th><span class="math inline">\(7\)</span></th>
<th><span class="math inline">\(8\)</span></th>
<th><span class="math inline">\(9\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(sa_i\)</span></td>
<td><span class="math inline">\(9\)</span></td>
<td><span class="math inline">\(-1\)</span></td>
<td><span class="math inline">\(2\)</span></td>
<td><span class="math inline">\(4\)</span></td>
<td><span class="math inline">\(6\)</span></td>
<td><span class="math inline">\(-1\)</span></td>
<td><span class="math inline">\(-1\)</span></td>
<td><span class="math inline">\(-1\)</span></td>
<td><span class="math inline">\(-1\)</span></td>
</tr>
</tbody>
</table>
<p>然后从左到右扫，插入<span class="math inline">\(L\)</span>型后缀（此步骤最好对照后文代码进行人工模拟，加深理解，这里只展示最后结果）：</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(i\)</span></th>
<th><span class="math inline">\(1\)</span></th>
<th><span class="math inline">\(2\)</span></th>
<th><span class="math inline">\(3\)</span></th>
<th><span class="math inline">\(4\)</span></th>
<th><span class="math inline">\(5\)</span></th>
<th><span class="math inline">\(6\)</span></th>
<th><span class="math inline">\(7\)</span></th>
<th><span class="math inline">\(8\)</span></th>
<th><span class="math inline">\(9\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(sa_i\)</span></td>
<td><span class="math inline">\(9\)</span></td>
<td><span class="math inline">\(-1\)</span></td>
<td><span class="math inline">\(2\)</span></td>
<td><span class="math inline">\(4\)</span></td>
<td><span class="math inline">\(6\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(3\)</span></td>
<td><span class="math inline">\(5\)</span></td>
<td><span class="math inline">\(8\)</span></td>
</tr>
</tbody>
</table>
<p>再根据<span class="math inline">\(L\)</span>型后缀扫回来：</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(i\)</span></th>
<th><span class="math inline">\(1\)</span></th>
<th><span class="math inline">\(2\)</span></th>
<th><span class="math inline">\(3\)</span></th>
<th><span class="math inline">\(4\)</span></th>
<th><span class="math inline">\(5\)</span></th>
<th><span class="math inline">\(6\)</span></th>
<th><span class="math inline">\(7\)</span></th>
<th><span class="math inline">\(8\)</span></th>
<th><span class="math inline">\(9\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(sa_i\)</span></td>
<td><span class="math inline">\(9\)</span></td>
<td><span class="math inline">\(6\)</span></td>
<td><span class="math inline">\(2\)</span></td>
<td><span class="math inline">\(4\)</span></td>
<td><span class="math inline">\(7\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(3\)</span></td>
<td><span class="math inline">\(5\)</span></td>
<td><span class="math inline">\(8\)</span></td>
</tr>
</tbody>
</table>
<p>很明显，已经lms后缀已经按照lms子串的大小排好序了。</p>
<blockquote>
<p>具体点来讲依然使用归纳法证明算法正确性。</p>
<p>我们知道初始的时候的lms数组是乱的，因此归纳的初始条件直接被打破了。</p>
<p>但是如果我们换个命题进行归纳呢？</p>
<p>我们一开始传进去的lms数组，如果只看开头的第一个字母，在后缀数组当中是有序的。</p>
<p>那么在第一轮诱导过后，对于每个L型后缀，如果只看这个后缀的开头到第一个S型字符位置的位置，他们也是有序的。</p>
<p>在第二轮诱导过后，对于每个S型后缀，它们有序的部分恰好是这个后缀的开头到第一个lms字符所在的位置，如果这个后缀是一个lms型后缀那么这个后缀有序的部分是这个后缀开头的lms字符。</p>
<p>所以我们证明了只需要再来一轮诱导排序就可以给所有lms子串排好序，然后我们就可以很轻松的完成离散化啦~</p>
<p>至此我们完成了SA-IS算法的最后一块拼图，此时我们已经可以尝试实现sais算法了~</p>
</blockquote>
<p>呃……神仙思路有点快，我们具体地继续考虑一下离散化，既然已经按照lms子串的大小排好序了，离散化lms子串实际上就只用暴力比较在目前的<span class="math inline">\(sa\)</span>数组中相邻的lms子串的大小，就可以知道离散后lms子串对应的字符是否相等，大小顺序就按已经部分排好的<span class="math inline">\(sa\)</span>数组来。</p>
<p>下面给出<a href="https://www.luogu.org/space/show?uid=56384" target="_blank" rel="noopener">shadowice1984</a>的代码<del>（注释也是她写的）</del>。</p>
<h3 id="代码">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">这里的诱导排序函数由于需要传非常多的参数，所以使用了宏的方式来实现了一个函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">具体的实现方式可以看下面的inds(lms)这个宏</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">由于多行宏旁边写不了注释我会在行上面写注释</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">sais的算法流程 :</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">1.确定每个后缀的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">2.确定第i个lms后缀的编号以及编号为i的后缀是第几个lms后缀</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">3.进行一次诱导排序给lms子串排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">4.扫描一遍得到的sa数组，生成用于递归的字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">5.如果新字符串中的每一个字符都不同，后缀数组可以直接计算，此处不递归</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">6.否则递归进行一次sais</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">7.根据之前记录了第i个lms后缀的编号和返回的后缀数组计算lms后缀的顺序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">8.进行一次诱导排序并返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">******************************************/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gm</span><span class="params">(T*&amp; bas, <span class="keyword">int</span> siz, T*&amp; op)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    op = bas;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bas += siz;<span class="comment">// 这里把内存提前申请好然后用指针分配内存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//这里sum表示桶的位置，cur是sum的一份copy，避免每次都要做前缀和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// S型后缀的桶是倒着开的也要倒着扫，L型后缀的桶的是正着开的也要正着扫</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pus(x) (sa[cur[a[x]]--] = x)  <span class="comment">// 插入S型后缀</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pul(x) (sa[cur[a[x]]++] = x)  <span class="comment">//插入诱导排序</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//诱导排序的宏，进行了两轮诱导过程:分别是从lms诱导到L和从L诱导到S</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inds(lms)                                         \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sa[i] = <span class="number">-1</span>;              \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[i] = <span class="number">0</span>;              \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[a[i]]++;             \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[i] += sum[i - <span class="number">1</span>];    \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cur[i] = sum[i];         \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; i--) pus(lms[i]);             \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cur[i] = sum[i - <span class="number">1</span>] + <span class="number">1</span>; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)                          \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sa[i] &gt; <span class="number">1</span> &amp;&amp; !tp[sa[i] - <span class="number">1</span>])                  \</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pul(sa[i] - <span class="number">1</span>);                               \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cur[i] = sum[i];         \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)                          \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sa[i] &gt; <span class="number">1</span> &amp;&amp; tp[sa[i] - <span class="number">1</span>])                   \</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pus(sa[i] - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sa[N];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum[N];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cur[N];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> rk[N];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A_bas[N &lt;&lt; <span class="number">4</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* A_t;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sais</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* a)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span>* tp;            <span class="comment">//现开数组现分配内存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gm(A_t, n + <span class="number">1</span>, tp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span>* p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gm(A_t, n + <span class="number">2</span>, p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tp[n] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//倒着扫一遍确定后缀类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) tp[i] = (a[i] == a[i + <span class="number">1</span>]) ? tp[i + <span class="number">1</span>] : (a[i] &lt; a[i + <span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//确定第i个lms后缀的编号和编号为i的后缀是第几个lms后缀</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rk[i] = (tp[i] &amp;&amp; !tp[i - <span class="number">1</span>]) ? (p[++m] = i, m) : <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//进行一轮诱导排序，生成新的字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    inds(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span>* a1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gm(A_t, m + <span class="number">1</span>, a1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p[m + <span class="number">1</span>] = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//扫一遍对lms子串进行离散化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((x = rk[sa[i]]) != <span class="number">-1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (tot == <span class="number">0</span> || p[x + <span class="number">1</span>] - p[x] != p[y + <span class="number">1</span>] - p[y]) <span class="comment">//如果长度不一致显然不等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                tot++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//否则暴力for一遍比较两个lms串是否相等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p1 = p[x], p2 = p[y]; p2 &lt;= p[y + <span class="number">1</span>]; p1++, p2++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> ((a[p1] &lt;&lt; <span class="number">1</span> | tp[p1]) != (a[p2] &lt;&lt; <span class="number">1</span> | tp[p2])) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        tot++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            a1[y = x] = tot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (tot == m)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) sa[a1[i]] = i; <span class="comment">//如果字符互不相同就直接计算后缀数组，否则递归</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        sais(m, a1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) a1[i] = p[sa[i]]; <span class="comment">//还原lms子串的顺序，进行诱导排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    inds(a1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> mde[N];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[N];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tr[<span class="number">300</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    A_t = A_bas;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, mde + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (mde[n + <span class="number">1</span>] != <span class="string">'\0'</span>) n++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tr[mde[i]] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">300</span>; i++) tr[i] += tr[i - <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = tr[mde[i]] + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    a[++n] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sais(n, a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> tmp = sa[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (tmp) buf[++cnt] = tmp % <span class="number">10</span> + <span class="number">48</span>, tmp /= <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (cnt) <span class="built_in">putchar</span>(buf[cnt--]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">putchar</span>(<span class="string">' '</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//拜拜程序~</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="例题">例题</h2>
<h3 id="洛谷p3809模板后缀数组">洛谷P3809<a href="https://www.luogu.org/problem/P3809" target="_blank" rel="noopener">【模板】后缀数组</a></h3>
<p>思路：最基础的模板题</p>
<p>没什么好讲的，只不过<span class="math inline">\(\Theta(n log n)\)</span>也能过。</p>
<p>代码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_n 1000000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_char 256</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pus(pos) sa[cur[a[pos]]--]=pos</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pul(pos) sa[++cur[a[pos]]]=pos</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sizof(n) n&lt;&lt;2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> induce_sort(lmspos)\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">memset</span>(sa+<span class="number">1</span>,<span class="number">-1</span>,sizof(n));\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">memcpy</span>(cur,sum,sizof(n+<span class="number">1</span>));\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>; --i; )\</span></pre></td></tr><tr><td class="code"><pre><span class="line">		pus(lmspos[i]);\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">memcpy</span>(cur+<span class="number">1</span>,sum,sizof(n));\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; ++i&lt;=n; )\</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sa[i]&gt;<span class="number">1</span>&amp;&amp;!tp[sa[i]<span class="number">-1</span>]&amp;&amp;(pul(sa[i]<span class="number">-1</span>));\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">memcpy</span>(cur,sum,sizof(n+<span class="number">1</span>));\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>; --i; )\</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sa[i]&gt;<span class="number">1</span>&amp;&amp;tp[sa[i]<span class="number">-1</span>]&amp;&amp;(pus(sa[i]<span class="number">-1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cur[max_n+<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sais</span><span class="params">(<span class="keyword">int</span>*a,<span class="keyword">int</span> n,<span class="keyword">int</span>*sa)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">bool</span>*tp=<span class="keyword">new</span> <span class="keyword">bool</span>[n+<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	tp[n]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n; --i; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tp[i]=(a[i]==a[i+<span class="number">1</span>])?tp[i+<span class="number">1</span>]:(a[i]&lt;a[i+<span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span>*lms=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">4</span>&gt;&gt;<span class="number">1</span>],*num=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>],m=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	num[<span class="number">1</span>]=<span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; ++i&lt;=n; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		num[i]=(tp[i]&amp;&amp;!tp[i<span class="number">-1</span>])?(lms[++m]=i,m):<span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span>*sum=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">memset</span>(sum,<span class="number">0</span>,sizof(n+<span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; ++i&lt;=n; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		++sum[a[i]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; ++i&lt;=n; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sum[i]+=sum[i<span class="number">-1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	induce_sort(lms);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	lms[m+<span class="number">1</span>]=n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span>*a1=<span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>],tot=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,x,y; ++i&lt;=n; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span>(~(x=num[sa[i]]))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span>(!tot||lms[x+<span class="number">1</span>]-lms[x]!=lms[y+<span class="number">1</span>]-lms[y])</span></pre></td></tr><tr><td class="code"><pre><span class="line">				++tot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> p1=lms[x],p2=lms[y]; p1&lt;=lms[x+<span class="number">1</span>]; ++p1,++p2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span>(a[p1]!=a[p2]||tp[p1]!=tp[p2])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						++tot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			a1[y=x]=tot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span>(tot==m)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; ++i&lt;=m; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">			sa[a1[i]]=i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		sais(a1,m,sa);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; ++i&lt;=m; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		a1[i]=lms[sa[i]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	induce_sort(a1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">delete</span>[] tp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">delete</span>[] lms;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">delete</span>[] num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">delete</span>[] sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">delete</span>[] a1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[max_n+<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[max_n+<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sa[max_n+<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ton[max_char+<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> vT&gt; <span class="function"><span class="keyword">void</span> <span class="title">maxi</span><span class="params">(T&amp;x,vT val)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	(val&gt;x)&amp;&amp;(x=val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> vT&gt; <span class="function"><span class="keyword">void</span> <span class="title">mini</span><span class="params">(T&amp;x,vT val)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	(val&lt;x)&amp;&amp;(x=val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> n,minc=max_char,maxc=<span class="number">0</span>,i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">memset</span>(ton,<span class="number">0</span>,<span class="keyword">sizeof</span>(ton));</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; ++i &lt;= n; )&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		ton[s[i]]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		maxi(maxc,s[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		mini(minc,s[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	ton[minc<span class="number">-1</span>]=<span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(i = minc<span class="number">-1</span>; ++i &lt;= maxc; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		ton[i]+=ton[i<span class="number">-1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; ++i &lt;= n; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		a[i]=ton[s[i]<span class="number">-1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	a[n+<span class="number">1</span>]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	sais(a,n+<span class="number">1</span>,sa);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; ++i&lt;=n; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,sa[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sa[n+<span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></p>
<h3 id="洛谷p3809jsoi2007字符加密">洛谷P3809<a href="https://www.luogu.org/problem/P4051" target="_blank" rel="noopener">【JSOI2007】字符加密</a></h3>
<p>思路：将字符串复制一遍，放在末尾，接着后缀排序，并按要求输出。</p>
<p>如样例，即复制为JSOI07JSOI0#然后起始位置<span class="math inline">\(\le |S|\)</span>的后缀的开头<span class="math inline">\(|S|\)</span>个字符即为需排序的字符串，进行一遍后缀排序即可完成。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_n 100000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_char 255</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pus(x) (sa[cur[a[x]]--]=x)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pul(x) (sa[++cur[a[x]]]=x)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> induce_sort(lmspos)\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">memset</span>(sa+<span class="number">1</span>,<span class="number">-1</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ++ i &lt;= n; )\</span></pre></td></tr><tr><td class="code"><pre><span class="line">		++sum[a[i]];\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ++ i &lt;= n; )\</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sum[i]+=sum[i<span class="number">-1</span>];\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">memcpy</span>(cur,sum,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = m+<span class="number">1</span>; -- i; )\</span></pre></td></tr><tr><td class="code"><pre><span class="line">		pus(lmspos[i]);\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">memcpy</span>(cur+<span class="number">1</span>,sum,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ++i &lt;= n; )\</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span>(sa[i]&gt;<span class="number">1</span>&amp;&amp;!tp[sa[i]<span class="number">-1</span>])\</span></pre></td></tr><tr><td class="code"><pre><span class="line">			pul(sa[i]<span class="number">-1</span>);\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">memcpy</span>(cur,sum,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n+<span class="number">1</span>; --i; )\</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span>(sa[i]&gt;<span class="number">1</span>&amp;&amp;tp[sa[i]<span class="number">-1</span>])\</span></pre></td></tr><tr><td class="code"><pre><span class="line">			pus(sa[i]<span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sais</span><span class="params">(<span class="keyword">int</span>*a,<span class="keyword">int</span> n,<span class="keyword">int</span>*sa)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">bool</span> *tp=<span class="keyword">new</span> <span class="keyword">bool</span>[n+<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	tp[n]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n; --i; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tp[i]=(a[i]==a[i+<span class="number">1</span>])?tp[i+<span class="number">1</span>]:(a[i]&lt;a[i+<span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> *lms=<span class="keyword">new</span> <span class="keyword">int</span>[(n&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>],*num=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> m=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ++i &lt;= n; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		num[i]=(tp[i]&amp;&amp;!tp[i<span class="number">-1</span>])?((lms[++m]=i),m):<span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> sum[max_n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],cur[max_n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	induce_sort(lms);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> tot=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span>* a1=<span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	lms[m+<span class="number">1</span>]=n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,x,y; ++ i &lt;= n; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span>(~(x=num[sa[i]]))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span>(!tot||lms[x+<span class="number">1</span>]-lms[x]!=lms[y+<span class="number">1</span>]-lms[y])</span></pre></td></tr><tr><td class="code"><pre><span class="line">				++tot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> p1=lms[x],p2=lms[y]; p2&lt;=lms[y+<span class="number">1</span>]; ++p1,++p2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span>(a[p1]!=a[p2]||tp[p1]!=tp[p2])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						++tot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			a1[y=x]=tot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span>(tot==m)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; ++i&lt;=m; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">			sa[a1[i]]=i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		sais(a1,m,sa);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; ++ i &lt;= m; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		a1[i]=lms[sa[i]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	induce_sort(a1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">delete</span>[] tp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">delete</span>[] num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">delete</span>[] lms;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">delete</span>[] a1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[max_n+<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[max_n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sa[max_n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ton[max_char+<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> vT&gt; <span class="function"><span class="keyword">void</span> <span class="title">maxi</span><span class="params">(T&amp;x,vT val)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	(val&gt;x)&amp;&amp;(x=val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> vT&gt; <span class="function"><span class="keyword">void</span> <span class="title">mini</span><span class="params">(T&amp;x,vT val)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	(val&lt;x)&amp;&amp;(x=val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> n,minc=max_char,maxc=<span class="number">0</span>,i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">memset</span>(ton,<span class="number">0</span>,<span class="keyword">sizeof</span>(ton));</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; ++i &lt;= n; )&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		++ton[s[i]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">		maxi(maxc,s[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		mini(minc,s[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	ton[minc<span class="number">-1</span>]=<span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(i = minc<span class="number">-1</span>; ++i &lt;= maxc; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		ton[i]+=ton[i<span class="number">-1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; ++i &lt; n; )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		a[i+n]=a[i]=ton[s[i]<span class="number">-1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	a[n]=ton[s[n]<span class="number">-1</span>],a[n&lt;&lt;<span class="number">1</span>]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	sais(a,n&lt;&lt;<span class="number">1</span>,sa);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	s[<span class="number">0</span>]=s[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; ++i &lt;= (n&lt;&lt;<span class="number">1</span>); )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span>(sa[i]&lt;=n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="built_in">putchar</span>(s[sa[i]<span class="number">-1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>sa-is</tag>
        <tag>模板</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/post/test/</url>
    <content><![CDATA[<h1 id="this-is-a-test">this is a test</h1>
<h1 id="latex"><span class="math inline">\(Latex\)</span>:</h1>
<p><span class="math display">\[
\int_{0}^{n} 10 dx\\
1+1=2\\
\mathscr{F}\\
\overset{\mathbb{N}}{1+1=2}
\]</span></p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>P5021【NOIP2018D1T3】赛道修建 题解</title>
    <url>/post/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90NOIP2018D1T3%E3%80%91%E8%B5%9B%E9%81%93%E4%BF%AE%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="noip2018d1t3赛道修建-题解">NOIP2018D1T3赛道修建 题解</h1>
<h2 id="section"></h2>
<h3 id="题目大意">题目大意</h3>
<p><a href="https://www.luogu.org/problemnew/show/P5021" target="_blank" rel="noopener">题目链接</a></p>
<p>一棵树，给定每一条边的长度，要从其中选出<span class="math inline">\(m\)</span>条不重复的链，使得链长的最小值最大。<strong>（如果不太习惯“链”，可以查看括号中的注释，否则请忽略大部分括号）</strong></p>
<h3 id="简要分析">简要分析</h3>
<p>通过<del>查看题解</del>题目要求最小值最大，我们可以想到二分答案。</p>
<p>设需要判定的答案为<span class="math inline">\(ans\)</span>。</p>
<p>记以<span class="math inline">\(i\)</span>为<span class="math inline">\(LCA\)</span>的最优半链长度为<span class="math inline">\(f_{i}\)</span>。（即在<span class="math inline">\(i\)</span>的子树（包括<span class="math inline">\(i\)</span>）中尽量合成链长（赛道长）不小于<span class="math inline">\(ans\)</span>的链（赛道）后，剩余的以<span class="math inline">\(i\)</span>为链（赛道）的一端最长的链（赛道）的长度）。</p>
<p>易得<span class="math inline">\(f_{i}\)</span>从<span class="math inline">\(i\)</span>的子节点合并得来。</p>
<p>贴好我冗长的主要代码（<span class="math inline">\(deal\)</span>函数（用于更新对应节点的<span class="math inline">\(f\)</span>值并考虑对应节点的贡献）被我去掉了，相应位置只有声明的注释，<span class="math inline">\(deal\)</span>函数我会在下面<strong>重点讲解</strong>）： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_n 50000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> v,w,nxt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    node()&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    node(<span class="keyword">int</span> _v,<span class="keyword">int</span> _w,<span class="keyword">int</span> _nxt):v(_v),w(_w),nxt(_nxt)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> head[max_n+<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    node edge[max_n&lt;&lt;<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head)),cnt=<span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        edge[++cnt]=node(v,w,head[u]),head[u]=cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree tr;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> que[max_n+<span class="number">1</span>];<span class="comment">//确保先遍历子节点，然后遍历父节点的遍历（类似于后序遍历）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[max_n+<span class="number">1</span>];<span class="comment">//在check函数中记录i节点的值是否已知（用于在deal函数中判断是否为父节点）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[max_n+<span class="number">1</span>];<span class="comment">//dp数组，详见分析部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> son[max_n+<span class="number">1</span>];<span class="comment">//在deal函数中记录儿子节点上传的f值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _count;<span class="comment">//在deal函数中记录儿子节点的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//int deal(int num,int expected,int&amp;cnt);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> ans)</span></span>&#123;<span class="comment">//二分答案的判断函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i,cnt=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        f[que[i]]=deal(que[i],ans,cnt),vis[que[i]]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(cnt&gt;=m)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        	<span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tr.build();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i,j,u,v,l,r,mid,cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp; n,&amp; m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    r=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp; u,&amp; v,&amp; l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tr.add(u,v,l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tr.add(v,u,l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        r+=l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//处理遍历数组（挪用vis数组记录是否访问过），也可以用dfs实现：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    que[n]=<span class="number">1</span>,vis[<span class="number">1</span>]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cnt=n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(i = n; i; i --)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(j = tr.head[que[i]]; ~j; j = tr.edge[j].nxt)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(!vis[tr.edge[j].v])</span></pre></td></tr><tr><td class="code"><pre><span class="line">                vis[tr.edge[j].v]=<span class="number">1</span>,que[--cnt]=tr.edge[j].v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//二分答案：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    l=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    r/=m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ++r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(l&lt;r<span class="number">-1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mid=(l+r)&gt;&gt;<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(check(mid))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            l=mid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            r=mid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure> ## 状态转移 大多数题解中都是用一个<span class="math inline">\(multiset\)</span>来记录上面代码的<span class="math inline">\(son\)</span>数组。从小到大枚举元素，如果在<span class="math inline">\(multiset\)</span>中有元素可以与之组成满足要求的链（赛道），则选最小（贪心思想 <del>，本文没有严格证明，理解请自行脑补，图片留坑</del>）的一个组成，答案<span class="math inline">\(+1\)</span>，并把它们从<span class="math inline">\(multiset\)</span>中删去，最后<span class="math inline">\(f\)</span>值取<span class="math inline">\(multiset\)</span>中剩余的最大的值。</p>
<p>但是，我们现在要用一个优秀的贪心将这个问题解决，以优化时间复杂度 <del>（尽管<strong>我的</strong>代码的时间复杂度并没有变）</del></p>
<h3 id="贪心全文重点">贪心——全文重点</h3>
<p>先声明一下<span class="math inline">\(deal\)</span> 函数的参数：</p>
<ul>
<li><span class="math inline">\(num\)</span>：当前节点编号</li>
<li><span class="math inline">\(expected\)</span>：期望赛道长度（即要判断的答案）</li>
<li><span class="math inline">\(cnt\)</span>：定义在<span class="math inline">\(check\)</span>函数里的全局贡献，传引用进行更新</li>
</ul>
<p>再声明一下几个主要的变量：</p>
<ul>
<li><span class="math inline">\(l,r\)</span>：两个指针，具体意义下面解释</li>
<li><span class="math inline">\(ll,rr\)</span>：两个用于记录的临时变量，具体含义中途可能会变化，但结合代码很好猜测和理解</li>
<li><span class="math inline">\(ret\)</span>：返回值，即最后<span class="math inline">\(f_{num}\)</span>的值</li>
<li><span class="math inline">\(cntt\)</span>：计数器，<span class="math inline">\(son\)</span>数组中长度不小于<span class="math inline">\(\frac{expected}{2}\)</span>，但没有被选的数量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,l,ll,r,rr,ret,cntt;</span></pre></td></tr></table></figure>
<p>先将子节点的信息更新到<span class="math inline">\(son\)</span>数组，若能单独成链（赛道），则答案<span class="math inline">\(+1\)</span>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_count=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = tr.head[num]; ~i; i = tr.edge[i].nxt)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(vis[tr.edge[i].v])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    	<span class="keyword">if</span>((f[tr.edge[i].v]+tr.edge[i].w)&gt;=expected)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    		cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    	<span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        	son[++_count]=f[tr.edge[i].v]+tr.edge[i].w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">stable_sort(son+<span class="number">1</span>,son+_count+<span class="number">1</span>);<span class="comment">//如果换成桶排即可提升时间复杂度</span></span></pre></td></tr></table></figure> 接着寻找<span class="math inline">\(r\le\frac{expected}{2}\text{，但}l\ge\frac{expected}{2}\)</span>，用<span class="math inline">\(l\)</span>和<span class="math inline">\(r\)</span>组成链（赛道）得到的最大贡献（此时<span class="math inline">\(ret\)</span>只记录大于<span class="math inline">\(\frac{expected}{2}\)</span>的值，<span class="math inline">\(ll\)</span>为正好大于<span class="math inline">\(\frac{expected}{2}\)</span>的最小值）</p>
<p>（本句设<span class="math inline">\(k&lt;r\)</span>）因为<span class="math inline">\(r\)</span>从大到小枚举，如果<span class="math inline">\(son_{r}\)</span>不能匹配，<span class="math inline">\(son_{k}\)</span>也无法匹配；但若<span class="math inline">\(son_{k}\)</span>能匹配，<span class="math inline">\(son_{r}\)</span>一定能匹配。综上所述，尽量用<span class="math inline">\(son_{r}\)</span>匹配。</p>
<p>代码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll=l=lower_bound(son+<span class="number">1</span>,son+_count+<span class="number">1</span>,(expected+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)-son;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(l&gt;_count)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> son[_count];</span></pre></td></tr><tr><td class="code"><pre><span class="line">r=l<span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ret=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cntt=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(r&amp;&amp;l&lt;=_count)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span>(son[l]+son[r]&lt;expected)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		ret=son[l];</span></pre></td></tr><tr><td class="code"><pre><span class="line">		l++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cntt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    l++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    r--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure> 处理未匹配的但<span class="math inline">\(\ge \frac{expected}{2}\)</span>的值，两两匹配： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(l&lt;=_count)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cntt+=(_count-l+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(cntt&amp;<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ret=son[_count];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cnt+=cntt&gt;&gt;<span class="number">1</span>;</span></pre></td></tr></table></figure> 如果<span class="math inline">\(\ge \frac{expected}{2}\)</span>的全部匹配完了，ret只能从<span class="math inline">\(&lt;\frac{expected}{2}\)</span>的值中计算。</p>
<p>因为已经计算出<span class="math inline">\(\ge \frac{expected}{2}\)</span>的只能有<span class="math inline">\(\frac{cntt}{2}\)</span>个不和<span class="math inline">\(&lt;\frac{expected}{2}\)</span>的匹配，所以<span class="math inline">\(l\)</span>尽量用大的匹配，<span class="math inline">\(r\)</span>在可能的情况下使用小的。</p>
<p>代码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(cntt&amp;<span class="number">1</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    r=<span class="number">1</span>,l=_count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    rr=ll<span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll+=cntt&gt;&gt;<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(l&gt;=ll)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(son[l]+son[r]&lt;expected)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ret=son[r];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            r++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        l--,r++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(r&lt;=rr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    	ret=son[rr];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></p>
<p><a href="https://www.luogu.org/recordnew/show/19602377" target="_blank" rel="noopener">完整代码</a></p>
<p>如果能给出贪心的反例或者严格证明，请联系笔者。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>NOIP</tag>
        <tag>二分答案</tag>
        <tag>树上dp</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
