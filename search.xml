<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Sa-Is]]></title>
    <url>%2Fpost%2Fsa-is%2F</url>
    <content type="text"><![CDATA[SA-IS算法 前言 先丢个洛谷日报的链接SA-IS算法。一下慢慢解读抄袭这篇博客。本文也可以与shadowice1984的洛谷日报同步阅读，增加解释疑惑。 SA-IS算法，全名Suffix-Array-Induce-Sort。 induce sort 指的是一个叫诱导排序的算法（下文重点）。SA-IS算法的精髓便是基于根据两个后缀首字母是否相同与其他已知信息来比较后缀的诱导排序。基于诱导排序，本算法可在\(O(|S|)\)的时间复杂度内进行后缀排序。 具体实现 \(S\)型后缀与\(L\)型后缀 全文阅读注释 为了方便我们推导各种各样的性质我们先把一个字符串的后缀分成两类,S型后缀和L型后缀，并且为了规避各种各样的分情况讨论，我们在字符串的后面需要加一个哨兵字符“#”。 好吧，我承认，加个烧饼哨兵字符的确可以方便不少，因为第\(|S|\)（下文中字符串长度\(|S|\)也会记作\(n\)）个字符开始的后缀（第\(i\)个字符开始的后缀在原文中也记作：后缀\(i\)）需要用到后缀\(n+1\)的诸多信息，为了让代码短一点。哨兵字符的大小为比该字符串任意字符小的字符（不影响排序结果）。 记后缀\(i\)为\(Suf(i)\) 记一个后缀\(S\)的类型为\(S.type\)。（可以跳过去先看一下定义） 例子： 若\(S=\)"\(banana\)"，则\(Suf(4)=\)"\(ana\)"，\(Suf(4).type=S\)。 另，记排序后的后缀的开头位置构成的数组为\(sa\)（即洛谷模板题的答案数组），编号由\(1\)开始，\(sa_1\)明显是指哨兵字符。 注：关于时间复杂度的具体内容（如证明），本文暂且留坑。 注：由于本人代码太丑，贴原博客代码 定义 "#"是一个\(S\)型后缀。 如果后缀\(i\)比后缀\(i+1\)小，\(i\)就是\(S\)型后缀，否则就是\(L\)型后缀。 性质 推论1：若\(S_i=S_{i+1}\)，则\(Suf(i).type=Suf(i+1).type\) 证明： 由\(S_i=S_{i+1}\)，则比较\(Suf(i)\)与\(Suf(i+1)\)相当于后移一位比较\(Suf(i+1)\)与\(Suf(i+2)\)。由后缀类型定义即可证得。 注：本文证明以提供思路为主要目的，故并不形式。希望大佬莫喷。 推论2：若\(S_i=S_j\)且\(Suf(i).type=S\)且\(Suf(j).type=L\)，则\(Suf(i)&gt;Suf(j)\) 证明： 由\(S_i=S_j\)，则须比较\(Suf(i+1)\)和\(Suf(j+1)\)。由于\(Suf(i).type=S\)，则\(S_{i+1}\le S_i\)，由于\(Suf(j).type=L\)，则\(S_{j+1}\le S_j\)。 已知\(a_{j+1}\le a_j=a_i \le a_{i+1}\)，若\(a_i \ne a_{i+1}\)或\(a_j\ne a_{j+1}\)，结论显然成立。 若\(a_{j+1}=a_j=a_i=a_{i+1}\)，由推论1，\(Suf(i+1).type=S,Suf(j+1).type=L\)，问题递归转化为\(Suf(i+1)\)与\(Suf(j+1)\)。 由数学归纳法，我们只用证明边界情况：字符串末尾。 如果\(i&lt;j\)，即类型为\(L\)的\(j\)判断到了边界，结论明显成立。 如果\(i=j\)，明显矛盾。 如果\(i&gt;j\)，则是\(i\)碰到了边界，即从\(i\)到\(n\)全部是\(S\)型后缀且相等，则不满足\(Suf(i)&lt;Suf(i+1)\)，与\(S\)型后缀定义矛盾。 代码实现 我们可以先从右到左扫一遍，因为已经处理出来后面每一个后缀的类型，由推论1我们就可以求出当前位置的类型。时间复杂度\(\Theta(n)\) 诱导排序(induce sort) sais的核心是诱导排序，但是诱导排序的正确性是基于归纳法证明的.所以这个算法不太好理解，它很简单，但是你可能理解不了为什么它是对的。 笔者就花了很长时间感性理解这个算法。从现在开始，建议不懂的可以暂时跳过，到后面出问题了或者读到末尾还没懂再回头看，或许会好理解不少。 由推论2，易得在后缀数组中首字母相同时\(L\)型后缀在\(S\)型后缀前面。 那么我们不妨可以将\(L\)型后缀和\(S\)型后缀分别排序，最后用归并排序的思想将后缀数组处理完成。 现在我们从\(L\)型后缀开始，思考一下如何对相同类型进行后缀排序。 如果两个\(L\)型后缀的首字母不一样，那么很好处理，否则我们就递归比较\((i+1,j+1)\)。基于这个思想直接处理有点麻烦，不如我们： 总体思路： 假设已经知道了部分后缀的大小关系（后文重点介绍，学这个算法切忌着急），然后我们可以将已知的最小的后缀为\(Suf(i)\)，那么如果\(Suf(i-1).type=L\)，即\(Suf(i-1)&gt;Suf(i)\)，将\(i-1\)加入我们现在已知的集合中，然后将\(i\)放入排序数组，并从集合删除，维护这个集合。最后我们可以知道与初始集合有关的所有\(L\)型后缀之间的关系。 如果用堆来维护刚才的过程，复杂度带log无法接受，但是我们有一个巧妙的做法可以完成上述过程。 精益求精的shadowice巨佬！！！ （依然维持刚才的假设。）我们直接维护\(sa\)数组，先记录每个首字母开头有多少后缀，便可以得知首字母为\(i\)的后缀从\(sa\)数组的哪里开始和结束。代码实现时先把\(sa\)初始化为\(-1\)。然后我们刚才插入的过程便可以直接在数组上维护！（具体代码实现部分会有介绍。） 我们从左到右扫一遍\(sa\)数组，如果第\(i\)个位置已知，且\(Suf(sa_i-1).type=L\)，我们就将\(L\)型后缀\(Suf(sa_i-1)\)插入到下一个位置。 (你可以把插入的过程理解为将sa数组按照首字母划分为若干个桶，然后将这个后缀push到对应的桶里去，代码上写起来和倍增法的基排没啥区别） 这样子，我们便可以在假设的基础上，用\(\Theta(n)\)的时间复杂度实现上述算法。 如果我们知道所有\(S\)型后缀，我们便可以用上述算法得到所有\(L\)型数组；对称的，知道所有\(L\)型后缀，也可以得到所有\(S\)型后缀。（这就是诱导排序的主体部分） 原理很简单：以从\(S\)型导入到\(L\)型为例，由于最后一个不是\(L\)型，每一个\(L\)型后缀\(Suf(i)\)都可以由\(Suf(i+1)\)得到，因为是\(L\)型，所以\(Suf(i)&gt;Suf(i+1)\)是肯定成立的（具体类似于推论2，可以由推论1证明，有兴趣可以自证）。这样子，\(L\)型后缀按顺序插入，不会有遗漏。 \(S\)型后缀的加入则要换个顺序，道理是对称的。 这样只要我们一开始掌握的后缀的大小信息无误并且足够的多，我们就能正确的还原出一个有序的sa数组，具体点，我们知道了关于S型的大小信息可以生成L型后缀的信息，知道了L型后缀的信息也可以还原出S型后缀的所有信息。 但是，前提是刚才的假设…… （只要你知道了诱导排序的作用就请先看下去，后面有lms子串诱导排序的模拟过程） 全文重点！！！ lms子串与lms后缀 为了方便处理这个棘手的问题，我们先引入一个概念：lms子串 诱导排序算法允许我们从\(L\)诱导到\(S\)，也允许从\(S\)诱导到\(L\)。但是诱导时并不需要全部的信息，我们只用扫描方向边界的信息即可。具体而言： 把诱导排序算法的正确性证明念一遍，我们会发现关键在于递归比较\((Suf(i+1),Suf(j+1))\)的大小关系这一段，如果\(Suf(i)\)和都是\(Suf(j)\)都是L型后缀，我们不能保证\((Suf(i+1),Suf(j+1))\)都是L型后缀。 但是，我们也仅仅需要左边是\(L\)型后缀的\(S\)型后缀的大小信息了。我们把这样的后缀定义为lms后缀(Left-Most-Suffix)。 我们可以把诱导排序升级到2.0版本：假设我们已经知道了所有lms后缀的大小关系，先从lms后缀大小关系诱导出\(L\)型后缀的大小关系，再诱导到\(S\)型。这样我们就可以知道最终的答案了。 由于已经有脑洞打开的神仙解决了这个难题假设，我们就可以省许多脑细胞了： 虽然是\(\Theta(n)\)，但是我们依然可以递归！！！ 显然，最多有\(\frac{n}{2}\)个lms后缀，时间复杂度即是： \[ T(n)=T(\frac{n}{2})+\Theta(n)\notag \] 但是我们还是不会递归问题 我们定义lms子串为从左到右数第\(i\)个lms后缀和\(i+1\)个lms后缀之间的字符串。 例子： \(i\) \(1\) \(2\) \(3\) \(4\) \(5\) \(6\) \(7\) \(8\) \(9\) \(S_i\) b a n a n a a s # \(Suf(i).type\) \(L\) \(S\) \(L\) \(S\) \(L\) \(S\) \(S\) \(L\) \(S\) 是否为lms 是 是 是 是 lms子串为\([2,4]\)、\([4,6]\)和\([6,9]\) 注意：相邻两个lms子串会重叠一个字符。 我们可以将lms子串离散化之后再按顺序拼成一个新的字符串，比如说对上面的lms子串进行离散化后变成\(2\)、\(2\)、\(1\)。拼成字符串"221"。 就是把一串字符离散成一个字符（往往读入完会进行第一次离散，所有字符变成数字处理）。 但是其实并没有我们想的那么显然，我们接下来会严谨的证明离散化的正确性。 首先先明确一下比较lms子串的规则，我们比较两个lms子串的时候对于每一个字符同时比较字符的字典序大小和所在位置后缀的\(S\)\(L\)类型,举个例子，我们认为\((&#39;a&#39;,S)\)和\((&#39;a&#39;,L)\)是不相等的，尽管字符一样但是所在位置的\(S\)和\(L\)类型却不一样，同时我们认为\(S\)类型大于\(L\)类型。 假设我们有两个lms后缀：第\(i\)个lms后缀\(Suf(p_1)\)和第\(j\)个lms后缀\(Suf(p_2)\),现在我们想要比较两个后缀的大小，我们可以根据两个后缀在新字符串上第一位的字符（\(S_i\)和\(S_j\)）是否相等来进行分情况讨论。 case1:第一位的字符是相等的 我们发现新字符串上两个字符相等,等价于原来字符串上两个lms子串相等，那么既然两个lms子串相等了那么这两个子串的长度\(len\)必然是一样的，因此我们可以将两个后缀同时去掉长度为\(len-1\)的部分递归比较剩下的部分，在新字符串上也就是递归到了第\(i+1\)位和第\(j+1\)位，符合我们字符串比较的逻辑。 case2:第一位的字符是不等的 那么你可能会说:既然新字符串的两个字符都不一样了，就说明在原来的字符串上肯定有不一样的位，所以这种情况是显然的。 那好像我们忽视了一种情况哎，两个lms子串代表的字符不一样是因为其中一个是另一个的前缀。 这种情况下我们的算法就会锅掉，因为两个后缀明明没有分出大小我们就强行钦定一个大于另一个了。 事实果真如此吗？ 答案是这种情况不存在，我们比较lms子串的规则是同时比较字符和\(S\)\(L\)类型的后缀，在这种情况下不存在一个lms子串是另一个的前缀，因为一个lms子串的\(S\)\(L\)类型必须是形如\(SSSSLLLLS\)这样的，前面是一串\(S\)中间是一串\(L\)，最后是恰好一个\(S\)，那么我们发现如果一个是另一个的前缀，两个串必然会在短的字符串的结尾处\(S\)\(L\)类型不匹配，从而不存在这种情况。 现在就是怎么离散的问题没解决了。 离散化lms子串与诱导排序之间的关系 如果我们实现这一步使用的是基数排序那么我们将会得到传说中的KA-algorithm，但是这东西很慢啊……我们想想有没有什么优秀的排序做法。 好吧…… 答案还是诱导排序，传统的诱导排序要求我们传一个有序的lms后缀数组进去，但是现在我们可以乱序传入lms后缀数组，当然诱导排序会返回一个错误的结果， 但是我们断言，在返回的后缀数组当中关于lms后缀的子序列是按照每个lms后缀开头的lms子串为关键字进行排序的 呃……有点难理解，我们举一个例子： \(bananaas\)#怎么又是这个串 lms后缀的数组： \(i\) \(1\) \(2\) \(3\) \(4\) \(lms_i\) \(2\)（\(ananaas\)#） \(4\)（\(anaas\)#） \(6\)（\(aas\)#） \(9\)（#） 显然，初始是按起始位置排序的。 记录每一个字符结束位置的\(sum\)数组（其实就是桶数组的前缀和）（为了方便理解，初始时不进行离散化，即下标为字符）： \(i\) \(&#39;\)#\(&#39;\) \(&#39;a&#39;\) \(&#39;b&#39;\) \(&#39;n&#39;\) \(&#39;s&#39;\) \(sum_i\) \(1\) \(5\) \(6\) \(8\) \(9\) \(sa\)数组先按倒序（在\(sa\)数组中便是正序）插入lms后缀： \(i\) \(1\) \(2\) \(3\) \(4\) \(5\) \(6\) \(7\) \(8\) \(9\) \(sa_i\) \(9\) \(-1\) \(2\) \(4\) \(6\) \(-1\) \(-1\) \(-1\) \(-1\) 然后从左到右扫，插入\(L\)型后缀（此步骤最好对照后文代码进行人工模拟，加深理解，这里只展示最后结果）： \(i\) \(1\) \(2\) \(3\) \(4\) \(5\) \(6\) \(7\) \(8\) \(9\) \(sa_i\) \(9\) \(-1\) \(2\) \(4\) \(6\) \(1\) \(3\) \(5\) \(8\) 再根据\(L\)型后缀扫回来： \(i\) \(1\) \(2\) \(3\) \(4\) \(5\) \(6\) \(7\) \(8\) \(9\) \(sa_i\) \(9\) \(6\) \(2\) \(4\) \(7\) \(1\) \(3\) \(5\) \(8\) 很明显，已经lms后缀已经按照lms子串的大小排好序了。 具体点来讲依然使用归纳法证明算法正确性。 我们知道初始的时候的lms数组是乱的，因此归纳的初始条件直接被打破了。 但是如果我们换个命题进行归纳呢？ 我们一开始传进去的lms数组，如果只看开头的第一个字母，在后缀数组当中是有序的。 那么在第一轮诱导过后，对于每个L型后缀，如果只看这个后缀的开头到第一个S型字符位置的位置，他们也是有序的。 在第二轮诱导过后，对于每个S型后缀，它们有序的部分恰好是这个后缀的开头到第一个lms字符所在的位置，如果这个后缀是一个lms型后缀那么这个后缀有序的部分是这个后缀开头的lms字符。 所以我们证明了只需要再来一轮诱导排序就可以给所有lms子串排好序，然后我们就可以很轻松的完成离散化啦~ 至此我们完成了SA-IS算法的最后一块拼图，此时我们已经可以尝试实现sais算法了~ 呃……神仙思路有点快，我们具体地继续考虑一下离散化，既然已经按照lms子串的大小排好序了，离散化lms子串实际上就只用暴力比较在目前的\(sa\)数组中相邻的lms子串的大小，就可以知道离散后lms子串对应的字符是否相等，大小顺序就按已经部分排好的\(sa\)数组来。 下面给出shadowice1984的代码（注释也是她写的）。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/******************************************这里的诱导排序函数由于需要传非常多的参数，所以使用了宏的方式来实现了一个函数具体的实现方式可以看下面的inds(lms)这个宏由于多行宏旁边写不了注释我会在行上面写注释sais的算法流程 :1.确定每个后缀的类型2.确定第i个lms后缀的编号以及编号为i的后缀是第几个lms后缀3.进行一次诱导排序给lms子串排序4.扫描一遍得到的sa数组，生成用于递归的字符串5.如果新字符串中的每一个字符都不同，后缀数组可以直接计算，此处不递归6.否则递归进行一次sais7.根据之前记录了第i个lms后缀的编号和返回的后缀数组计算lms后缀的顺序8.进行一次诱导排序并返回******************************************/#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;typedef long long ll;template &lt;typename T&gt;inline void gm(T*&amp; bas, int siz, T*&amp; op) &#123; op = bas; bas += siz;// 这里把内存提前申请好然后用指针分配内存&#125;//这里sum表示桶的位置，cur是sum的一份copy，避免每次都要做前缀和// S型后缀的桶是倒着开的也要倒着扫，L型后缀的桶的是正着开的也要正着扫#define pus(x) (sa[cur[a[x]]--] = x) // 插入S型后缀#define pul(x) (sa[cur[a[x]]++] = x) //插入诱导排序//诱导排序的宏，进行了两轮诱导过程:分别是从lms诱导到L和从L诱导到S#define inds(lms) \ for (int i = 1; i &lt;= n; i++) sa[i] = -1; \ for (int i = 1; i &lt;= n; i++) sum[i] = 0; \ for (int i = 1; i &lt;= n; i++) sum[a[i]]++; \ for (int i = 1; i &lt;= n; i++) sum[i] += sum[i - 1]; \ for (int i = 1; i &lt;= n; i++) cur[i] = sum[i]; \ for (int i = m; i &gt;= 1; i--) pus(lms[i]); \ for (int i = 1; i &lt;= n; i++) cur[i] = sum[i - 1] + 1; \ for (int i = 1; i &lt;= n; i++) \ if (sa[i] &gt; 1 &amp;&amp; !tp[sa[i] - 1]) \ pul(sa[i] - 1); \ for (int i = 1; i &lt;= n; i++) cur[i] = sum[i]; \ for (int i = n; i &gt;= 1; i--) \ if (sa[i] &gt; 1 &amp;&amp; tp[sa[i] - 1]) \ pus(sa[i] - 1);int sa[N];int sum[N];int cur[N];int rk[N];int A_bas[N &lt;&lt; 4];int* A_t;inline void sais(int n, int* a) &#123; int* tp; //现开数组现分配内存 gm(A_t, n + 1, tp); int* p; gm(A_t, n + 2, p); tp[n] = 1; //倒着扫一遍确定后缀类型 for (int i = n - 1; i &gt;= 1; i--) tp[i] = (a[i] == a[i + 1]) ? tp[i + 1] : (a[i] &lt; a[i + 1]); //确定第i个lms后缀的编号和编号为i的后缀是第几个lms后缀 int m = 0; for (int i = 1; i &lt;= n; i++) rk[i] = (tp[i] &amp;&amp; !tp[i - 1]) ? (p[++m] = i, m) : -1; //进行一轮诱导排序，生成新的字符串 inds(p); int tot = 0; int* a1; gm(A_t, m + 1, a1); p[m + 1] = n; //扫一遍对lms子串进行离散化 for (int i = 1, x, y; i &lt;= n; i++) if ((x = rk[sa[i]]) != -1) &#123; if (tot == 0 || p[x + 1] - p[x] != p[y + 1] - p[y]) //如果长度不一致显然不等 tot++; //否则暴力for一遍比较两个lms串是否相等 else for (int p1 = p[x], p2 = p[y]; p2 &lt;= p[y + 1]; p1++, p2++) if ((a[p1] &lt;&lt; 1 | tp[p1]) != (a[p2] &lt;&lt; 1 | tp[p2])) &#123; tot++; break; &#125; a1[y = x] = tot; &#125; if (tot == m) for (int i = 1; i &lt;= m; i++) sa[a1[i]] = i; //如果字符互不相同就直接计算后缀数组，否则递归 else sais(m, a1); for (int i = 1; i &lt;= m; i++) a1[i] = p[sa[i]]; //还原lms子串的顺序，进行诱导排序 inds(a1);&#125;char mde[N];int n;int a[N];int tr[300];char buf[20];int cnt;int main() &#123; A_t = A_bas; scanf("%s", mde + 1); while (mde[n + 1] != '\0') n++; for (int i = 1; i &lt;= n; i++) tr[mde[i]] = 1; for (int i = 1; i &lt; 300; i++) tr[i] += tr[i - 1]; for (int i = 1; i &lt;= n; i++) a[i] = tr[mde[i]] + 1; a[++n] = 1; sais(n, a); for (int i = 2; i &lt;= n; i++) &#123; int tmp = sa[i]; while (tmp) buf[++cnt] = tmp % 10 + 48, tmp /= 10; while (cnt) putchar(buf[cnt--]); putchar(' '); &#125; return 0; //拜拜程序~&#125; 例题 洛谷P3809【模板】后缀数组 思路：最基础的模板题 没什么好讲的，只不过\(\Theta(n log n)\)也能过。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdio&gt;#include &lt;cstring&gt;#define max_n 1000000#define max_char 256using namespace std;#define pus(pos) sa[cur[a[pos]]--]=pos#define pul(pos) sa[++cur[a[pos]]]=pos#define sizof(n) n&lt;&lt;2#define induce_sort(lmspos)\ memset(sa+1,-1,sizof(n));\ memcpy(cur,sum,sizof(n+1));\ for(int i=m+1; --i; )\ pus(lmspos[i]);\ memcpy(cur+1,sum,sizof(n));\ for(int i=0; ++i&lt;=n; )\ sa[i]&gt;1&amp;&amp;!tp[sa[i]-1]&amp;&amp;(pul(sa[i]-1));\ memcpy(cur,sum,sizof(n+1));\ for(int i=n+1; --i; )\ sa[i]&gt;1&amp;&amp;tp[sa[i]-1]&amp;&amp;(pus(sa[i]-1));int cur[max_n+2];void sais(int*a,int n,int*sa)&#123; bool*tp=new bool[n+1]; tp[n]=1; for(int i=n; --i; ) tp[i]=(a[i]==a[i+1])?tp[i+1]:(a[i]&lt;a[i+1]); int*lms=new int[n+4&gt;&gt;1],*num=new int[n+1],m=0; num[1]=-1; for(int i=1; ++i&lt;=n; ) num[i]=(tp[i]&amp;&amp;!tp[i-1])?(lms[++m]=i,m):-1; int*sum=new int[n+1]; memset(sum,0,sizof(n+1)); for(int i=0; ++i&lt;=n; ) ++sum[a[i]]; for(int i=0; ++i&lt;=n; ) sum[i]+=sum[i-1]; induce_sort(lms); lms[m+1]=n; int*a1=new int[m+1],tot=0; for(int i=0,x,y; ++i&lt;=n; ) if(~(x=num[sa[i]]))&#123; if(!tot||lms[x+1]-lms[x]!=lms[y+1]-lms[y]) ++tot; else for(int p1=lms[x],p2=lms[y]; p1&lt;=lms[x+1]; ++p1,++p2) if(a[p1]!=a[p2]||tp[p1]!=tp[p2])&#123; ++tot; break; &#125; a1[y=x]=tot; &#125; if(tot==m) for(int i=0; ++i&lt;=m; ) sa[a1[i]]=i; else sais(a1,m,sa); for(int i=0; ++i&lt;=m; ) a1[i]=lms[sa[i]]; induce_sort(a1); delete[] tp; delete[] lms; delete[] num; delete[] sum; delete[] a1;&#125;char s[max_n+2];int a[max_n+2];int sa[max_n+2];int ton[max_char+1];template &lt;typename T,typename vT&gt; void maxi(T&amp;x,vT val)&#123; (val&gt;x)&amp;&amp;(x=val);&#125;template &lt;typename T,typename vT&gt; void mini(T&amp;x,vT val)&#123; (val&lt;x)&amp;&amp;(x=val);&#125;int main()&#123; int n,minc=max_char,maxc=0,i; scanf("%s",s+1); n=strlen(s+1); memset(ton,0,sizeof(ton)); for(i = 0; ++i &lt;= n; )&#123; ton[s[i]]=1; maxi(maxc,s[i]); mini(minc,s[i]); &#125; ton[minc-1]=2; for(i = minc-1; ++i &lt;= maxc; ) ton[i]+=ton[i-1]; for(i = 0; ++i &lt;= n; ) a[i]=ton[s[i]-1]; a[n+1]=1; sais(a,n+1,sa); for(int i=1; ++i&lt;=n; ) printf("%d ",sa[i]); printf("%d\n",sa[n+1]); return 0;&#125; 洛谷P3809【JSOI2007】字符加密 思路：将字符串复制一遍，放在末尾，接着后缀排序，并按要求输出。 如样例，即复制为JSOI07JSOI0#然后起始位置\(\le |S|\)的后缀的开头\(|S|\)个字符即为需排序的字符串，进行一遍后缀排序即可完成。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;cstring&gt;#define max_n 100000#define max_char 255using namespace std;#define pus(x) (sa[cur[a[x]]--]=x)#define pul(x) (sa[++cur[a[x]]]=x)#define induce_sort(lmspos)\ memset(sa+1,-1,sizeof(int)*n);\ memset(sum,0,sizeof(int)*(n+1));\ for(int i = 0; ++ i &lt;= n; )\ ++sum[a[i]];\ for(int i = 0; ++ i &lt;= n; )\ sum[i]+=sum[i-1];\ memcpy(cur,sum,sizeof(int)*(n+1));\ for(int i = m+1; -- i; )\ pus(lmspos[i]);\ memcpy(cur+1,sum,sizeof(int)*n);\ for(int i = 0; ++i &lt;= n; )\ if(sa[i]&gt;1&amp;&amp;!tp[sa[i]-1])\ pul(sa[i]-1);\ memcpy(cur,sum,sizeof(int)*(n+1));\ for(int i = n+1; --i; )\ if(sa[i]&gt;1&amp;&amp;tp[sa[i]-1])\ pus(sa[i]-1);void sais(int*a,int n,int*sa)&#123; bool *tp=new bool[n+1]; tp[n]=1; for(int i=n; --i; ) tp[i]=(a[i]==a[i+1])?tp[i+1]:(a[i]&lt;a[i+1]); int *lms=new int[(n&gt;&gt;1)+1],*num=new int[n+1]; int m=0; for(int i = 0; ++i &lt;= n; ) num[i]=(tp[i]&amp;&amp;!tp[i-1])?((lms[++m]=i),m):-1; static int sum[max_n&lt;&lt;1|1],cur[max_n&lt;&lt;1|1]; induce_sort(lms); int tot=0; int* a1=new int[m+1]; lms[m+1]=n; for(int i = 0,x,y; ++ i &lt;= n; ) if(~(x=num[sa[i]]))&#123; if(!tot||lms[x+1]-lms[x]!=lms[y+1]-lms[y]) ++tot; else for(int p1=lms[x],p2=lms[y]; p2&lt;=lms[y+1]; ++p1,++p2) if(a[p1]!=a[p2]||tp[p1]!=tp[p2])&#123; ++tot; break; &#125; a1[y=x]=tot; &#125; if(tot==m) for(int i=0; ++i&lt;=m; ) sa[a1[i]]=i; else sais(a1,m,sa); for(int i=0; ++ i &lt;= m; ) a1[i]=lms[sa[i]]; induce_sort(a1); delete[] tp; delete[] num; delete[] lms; delete[] a1;&#125;char s[max_n+2];int a[max_n&lt;&lt;1|1];int sa[max_n&lt;&lt;1|1];int ton[max_char+1];template &lt;typename T,typename vT&gt; void maxi(T&amp;x,vT val)&#123; (val&gt;x)&amp;&amp;(x=val);&#125;template &lt;typename T,typename vT&gt; void mini(T&amp;x,vT val)&#123; (val&lt;x)&amp;&amp;(x=val);&#125;int main()&#123; int n,minc=max_char,maxc=0,i; scanf("%s",s+1); n=strlen(s+1); memset(ton,0,sizeof(ton)); for(i = 0; ++i &lt;= n; )&#123; ++ton[s[i]]; maxi(maxc,s[i]); mini(minc,s[i]); &#125; ton[minc-1]=2; for(i = minc-1; ++i &lt;= maxc; ) ton[i]+=ton[i-1]; for(i = 0; ++i &lt; n; ) a[i+n]=a[i]=ton[s[i]-1]; a[n]=ton[s[n]-1],a[n&lt;&lt;1]=1; sais(a,n&lt;&lt;1,sa); s[0]=s[n]; for(i = 1; ++i &lt;= (n&lt;&lt;1); ) if(sa[i]&lt;=n) putchar(s[sa[i]-1]); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>sa-is</tag>
        <tag>模板</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P5021【NOIP2018D1T3】赛道修建 题解]]></title>
    <url>%2Fpost%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90NOIP2018D1T3%E3%80%91%E8%B5%9B%E9%81%93%E4%BF%AE%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[NOIP2018D1T3赛道修建 题解 题目大意 题目链接 一棵树，给定每一条边的长度，要从其中选出\(m\)条不重复的链，使得链长的最小值最大。（如果不太习惯“链”，可以查看括号中的注释，否则请忽略大部分括号） 简要分析 通过查看题解题目要求最小值最大，我们可以想到二分答案。 设需要判定的答案为\(ans\)。 记以\(i\)为\(LCA\)的最优半链长度为\(f_{i}\)。（即在\(i\)的子树（包括\(i\)）中尽量合成链长（赛道长）不小于\(ans\)的链（赛道）后，剩余的以\(i\)为链（赛道）的一端最长的链（赛道）的长度）。 易得\(f_{i}\)从\(i\)的子节点合并得来。 贴好我冗长的主要代码（\(deal\)函数（用于更新对应节点的\(f\)值并考虑对应节点的贡献）被我去掉了，相应位置只有声明的注释，\(deal\)函数我会在下面重点讲解）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define max_n 50000using namespace std;struct node&#123; int v,w,nxt; node()&#123;&#125; node(int _v,int _w,int _nxt):v(_v),w(_w),nxt(_nxt)&#123;&#125;&#125;;struct tree&#123; int head[max_n+1]; node edge[max_n&lt;&lt;1]; int cnt; void build()&#123; memset(head,-1,sizeof(head)),cnt=-1; &#125; void add(int u,int v,int w)&#123; edge[++cnt]=node(v,w,head[u]),head[u]=cnt; &#125;&#125;;tree tr;int que[max_n+1];//确保先遍历子节点，然后遍历父节点的遍历（类似于后序遍历）bool vis[max_n+1];//在check函数中记录i节点的值是否已知（用于在deal函数中判断是否为父节点）int f[max_n+1];//dp数组，详见分析部分int son[max_n+1];//在deal函数中记录儿子节点上传的f值int _count;//在deal函数中记录儿子节点的个数int n,m;//int deal(int num,int expected,int&amp;cnt);bool check(int ans)&#123;//二分答案的判断函数 int i,cnt=0; memset(vis,0,sizeof(vis)); for(i = 1; i &lt;= n; i ++)&#123; f[que[i]]=deal(que[i],ans,cnt),vis[que[i]]=1; if(cnt&gt;=m) return 1; &#125; return 0;&#125;int main()&#123; tr.build(); int i,j,u,v,l,r,mid,cnt; scanf("%d%d",&amp; n,&amp; m); r=0; for(i = 1; i &lt; n; i ++)&#123; scanf("%d%d%d",&amp; u,&amp; v,&amp; l); tr.add(u,v,l); tr.add(v,u,l); r+=l; &#125; //处理遍历数组（挪用vis数组记录是否访问过），也可以用dfs实现： que[n]=1,vis[1]=1; cnt=n; for(i = n; i; i --) for(j = tr.head[que[i]]; ~j; j = tr.edge[j].nxt) if(!vis[tr.edge[j].v]) vis[tr.edge[j].v]=1,que[--cnt]=tr.edge[j].v; //二分答案： l=1; r/=m; ++r; while(l&lt;r-1)&#123; mid=(l+r)&gt;&gt;1; if(check(mid)) l=mid; else r=mid; &#125; printf("%d\n",l); return 0;&#125; 状态转移 大多数题解中都是用一个\(multiset\)来记录上面代码的\(son\)数组。从小到大枚举元素，如果在\(multiset\)中有元素可以与之组成满足要求的链（赛道），则选最小（贪心思想 ，本文没有严格证明，理解请自行脑补，图片留坑）的一个组成，答案\(+1\)，并把它们从\(multiset\)中删去，最后\(f\)值取\(multiset\)中剩余的最大的值。 但是，我们现在要用一个优秀的贪心将这个问题解决，以优化时间复杂度 （尽管我的代码的时间复杂度并没有变） 贪心——全文重点 先声明一下\(deal\) 函数的参数： \(num\)：当前节点编号 \(expected\)：期望赛道长度（即要判断的答案） \(cnt\)：定义在\(check\)函数里的全局贡献，传引用进行更新 再声明一下几个主要的变量： \(l,r\)：两个指针，具体意义下面解释 \(ll,rr\)：两个用于记录的临时变量，具体含义中途可能会变化，但结合代码很好猜测和理解 \(ret\)：返回值，即最后\(f_{num}\)的值 \(cntt\)：计数器，\(son\)数组中长度不小于\(\frac{expected}{2}\)，但没有被选的数量 1int i,l,ll,r,rr,ret,cntt; 先将子节点的信息更新到\(son\)数组，若能单独成链（赛道），则答案\(+1\)： 12345678_count=0;for(i = tr.head[num]; ~i; i = tr.edge[i].nxt) if(vis[tr.edge[i].v]) if((f[tr.edge[i].v]+tr.edge[i].w)&gt;=expected) cnt++; else son[++_count]=f[tr.edge[i].v]+tr.edge[i].w;stable_sort(son+1,son+_count+1);//如果换成桶排即可提升时间复杂度 接着寻找\(r\le\frac{expected}{2}\text{，但}l\ge\frac{expected}{2}\)，用\(l\)和\(r\)组成链（赛道）得到的最大贡献（此时\(ret\)只记录大于\(\frac{expected}{2}\)的值，\(ll\)为正好大于\(\frac{expected}{2}\)的最小值） （本句设\(k&lt;r\)）因为\(r\)从大到小枚举，如果\(son_{r}\)不能匹配，\(son_{k}\)也无法匹配；但若\(son_{k}\)能匹配，\(son_{r}\)一定能匹配。综上所述，尽量用\(son_{r}\)匹配。 代码： 1234567891011121314151617ll=l=lower_bound(son+1,son+_count+1,(expected+1)&gt;&gt;1)-son;if(l&gt;_count) return son[_count];r=l-1;ret=0;cntt=0;while(r&amp;&amp;l&lt;=_count)&#123; if(son[l]+son[r]&lt;expected)&#123; ret=son[l]; l++; cntt++; continue; &#125; cnt++; l++; r--;&#125; 处理未匹配的但\(\ge \frac{expected}{2}\)的值，两两匹配： 123456if(l&lt;=_count)&#123; cntt+=(_count-l+1); if(cntt&amp;1) ret=son[_count];&#125;cnt+=cntt&gt;&gt;1; 如果\(\ge \frac{expected}{2}\)的全部匹配完了，ret只能从\(&lt;\frac{expected}{2}\)的值中计算。 因为已经计算出\(\ge \frac{expected}{2}\)的只能有\(\frac{cntt}{2}\)个不和\(&lt;\frac{expected}{2}\)的匹配，所以\(l\)尽量用大的匹配，\(r\)在可能的情况下使用小的。 代码： 123456789101112131415if(!(cntt&amp;1))&#123; r=1,l=_count; rr=ll-1; ll+=cntt&gt;&gt;1; while(l&gt;=ll)&#123; if(son[l]+son[r]&lt;expected)&#123; ret=son[r]; r++; continue; &#125; l--,r++; &#125; if(r&lt;=rr) ret=son[rr];&#125; 完整代码 如果能给出贪心的反例或者严格证明，请联系笔者。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>NOIP</tag>
        <tag>二分答案</tag>
        <tag>树上dp</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2Fpost%2Ftest%2F</url>
    <content type="text"><![CDATA[this is a test \(Latex\): \[ \int_{0}^{n} 10 dx\\ 1+1=2\\ \mathscr{F}\\ \overset{\mathbb{N}}{1+1=2} \]]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
